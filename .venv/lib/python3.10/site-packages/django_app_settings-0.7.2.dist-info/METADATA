Metadata-Version: 2.1
Name: django-app-settings
Version: 0.7.2
Summary: Application settings helper for Django apps.
Home-page: https://github.com/pawamoy/django-appsettings
Author: Timothee Mazzucotelli
Author-email: timothee.mazzucotelli@gmail.com
License: ISC
Keywords: django,app,settings
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: ISC License (ISCL)
Classifier: Operating System :: Unix
Classifier: Framework :: Django
Classifier: Framework :: Django :: 1.11
Classifier: Framework :: Django :: 2.0
Classifier: Framework :: Django :: 2.1
Classifier: Framework :: Django :: 2.2
Classifier: Framework :: Django :: 3.0
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Topic :: Utilities
Requires-Python: ~=3.5
License-File: LICENSE
License-File: AUTHORS.rst
Requires-Dist: Django

==================
Django AppSettings
==================



Application settings helper for Django apps.

Why another *app settings* app?
Because none of the other suited my needs!

This one is simple to use, and works with unit tests overriding settings.

Installation
============

::

    pip install django-app-settings

Documentation
=============

`On ReadTheDocs`_

.. _`On ReadTheDocs`: http://django-appsettings.readthedocs.io/

Development
===========

To run all the tests: ``tox``. See `CONTRIBUTING`_.

.. _`CONTRIBUTING`: https://github.com/pawamoy/django-appsettings/blob/master/CONTRIBUTING.rst

Quick usage
===========

.. code:: python

    # Define your settings class
    import appsettings


    class MySettings(appsettings.AppSettings):
        boolean_setting = appsettings.BooleanSetting(default=False)
        required_setting = appsettings.StringSetting(required=True)
        named_setting = appsettings.IntegerSetting(name='integer_setting')
        prefixed_setting = appsettings.ListSetting(prefix='my_app_')

        class Meta:
            setting_prefix = 'app_'


    # Related settings in settings.py
    APP_INTEGER_SETTING = -24
    MY_APP_PREFIXED_SETTING = []


    # Instantiate your class wherever you need to
    appconf = MySettings()
    assert appconf.boolean_setting is False  # True (default value)
    assert appconf.required_setting == 'hello'  # raises AttributeError
    assert appconf.named_setting < 0  # True
    assert appconf.prefixed_setting  # False (empty list)


    # Values are cached to avoid perf issues
    with override_settings(APP_REQUIRED_SETTING='hello',
                           APP_INTEGER_SETTING=0):
        # ...but cache is cleaned on Django's setting_changed signal
        assert appconf.required_setting == 'hello'  # True
        assert appconf.named_setting < 0  # False


    # You can still access settings through the class itself (values not cached)
    print(MySettings.boolean_setting.get_value())  # explicit call
    print(MySettings.boolean_setting.value)  # with property


    # Run type checking and required presence on all settings at once
    MySettings.check()  # raises Django's ImproperlyConfigured (missing required_setting)
    # MySettings.check() is best called in django.apps.AppConfig's ready method


You can easily create your own Setting classes for more complex settings.

.. code:: python

    import re

    import appsettings
    from django.core.exceptions import ValidationError


    class RegexSetting(appsettings.Setting):
        def validate(self, value):
            re_type = type(re.compile(r'^$'))
            if not isinstance(value, (re_type, str)):
                # Raise ValidationError
                raise ValidationError('Value must be a string or a compiled regex (use re.compile)')

        def transform(self, value):
            # ensure it always returns a compiled regex
            if isinstance(value, str):
                value = re.compile(value)
            return value


Please check the documentation to see even more advanced usage.

License
=======

Software licensed under `ISC`_ license.

.. _ISC: https://www.isc.org/downloads/software-support-policy/isc-license/


=========
Changelog
=========

Unreleased
==========


0.7.2 (2023-09-07)
==================

- Deprecate loding setting values from environment (#98 by @stinovlas)
- Fix optional nested dict setting (#92 by @rastytheamateur)
- Fix typos in ``usage.rst`` (#102 by @oto-stefan)
- Fix docs build (#100 by @stinovlas)

0.7.1 (2020-05-28)
==================

- Ignore environment variables when using ``override_settings``.
- Don't announce type annotations.

0.7.0 (2020-04-14)
==================

- Read setting values from environment variables.
- Add ``FileSetting``.
- Fix bug causing ``NestedDictSetting`` to be always required.
- Add support for python 3.8 and Django 3.0.
- Drop support for python 2.7 and 3.4.
- Drop deprecated type checkers.
- Add type annotations.
- Raise ``ImproperlyConfigured`` from ``Setting.check`` for all errors in a setting.
- Move repository to https://github.com/pawamoy/django-appsettings.
- Clean tests.

0.6.1 (2020-03-04)
==================

- Fix ``transform_default`` in ``NestedListSetting``, by @stinovlas (see PR `#61`_).

.. _#61: https://github.com/pawamoy/django-appsettings/issues/61

0.6.0 (2019-08-27)
==================

- Add ``CallablePathSetting`` (see issue `#49`_ and PR `#52`_).
- Add ``NestedListSetting`` (see issue `#50`_ and PR `#53`_).
- Rename ``NestedSetting`` to ``NestedDictSetting`` (old name is still available but deprecated).

.. _#49: https://github.com/pawamoy/django-appsettings/issues/49
.. _#50: https://github.com/pawamoy/django-appsettings/issues/50
.. _#52: https://github.com/pawamoy/django-appsettings/issues/52
.. _#53: https://github.com/pawamoy/django-appsettings/issues/53

0.5.1 (2019-05-23)
==================

- Fix default values for empty arguments.

0.5.0 (2018-12-03)
==================

- Deprecate setting checkers in favor of validators, similarly to Django form fields.

0.4.0 (2018-07-25)
==================

- Add ``NestedSetting`` for easy management of nested settings.

0.3.0 (2017-11-30)
==================

Going from alpha to beta status. Logic has been reworked.

- An instance of a subclass of ``AppSettings`` will now dynamically get
  settings values from project settings, and cache them. This allows to use
  the instance the same way in code and tests, without performance loss. See
  issue `#16`_.
- Cache is invalidated when Django sends a ``setting_changed`` signal (i.e.
  when using ``TestCase`` or ``override_settings``). See issue `#16`_.
- Setting main class now accepts callable as default value, and two new
  parameters to keep control on its behavior: ``call_default``, which tells
  if the default value should be called (if callable) or not, and
  ``transform_default``, which tells if the default value should be transformed
  as well by the ``transform`` method. See issue `#17`_.
- Settings type checkers now have custom parameters like ``max_length``,
  ``empty`` or ``key_type``, that can be passed directly through the settings
  classes as keyword arguments. Check the documentation for more information.
- Settings classes have been rewritten more explicitly, using class inheritance
  instead of hard-to-debug generators. Composed types like float lists or
  boolean sets have been removed in favor of more flexible list, set and tuple
  types which now accept an optional ``item_type`` parameter.
- ``ImportedObjectSetting`` has been renamed ``ObjectSetting``, and now
  supports object paths down to arbitrary level of nesting. Before, it only
  supported object paths down to classes or functions, now you can for example
  give it the path to a constant in a class within a class, itself contained
  in a module within a package. It will work as long a the deepest module is
  importable through ``importlib.import_module`` and each object down to the
  last is obtainable through ``getattr`` method.

Many thanks to `ziima`_ for having shared good ideas and thoughts!

.. _#16: https://github.com/pawamoy/django-appsettings/issues/16
.. _#17: https://github.com/pawamoy/django-appsettings/issues/17
.. _ziima: https://github.com/ziima

0.2.5 (2017-06-02)
==================

- Add six dependency (now required).
- Rename ``Int`` settings to ``Integer``, and ``Bool`` ones to ``Boolean``.
- Remove metaclass generated getters and checkers.

0.2.4 (2017-05-02)
==================

- Settings are not checked when they default to the provided default value.
- Settings classes received better default values corresponding to their types.

0.2.3 (2017-05-02)
==================

- Add ``full_name`` property to ``Setting`` class.
- Add ``required`` parameter to ``Setting`` class (default ``False``).

0.2.2 (2017-04-17)
==================

- Import settings classes in main module to simplify imports.

0.2.1 (2017-04-17)
==================

- Add ``PositiveInt`` and ``PositiveFloat`` settings.
- Add support for Django 1.11.
- Implement basic settings classes.

0.2.0 (2017-04-17)
==================

- Implement basic Setting class.
- Pin dependencies.
- Change distribution name to ``app-settings``.

0.1.0 (2017-03-23)
==================

- Alpha release on PyPI.
